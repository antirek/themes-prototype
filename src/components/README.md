# Архитектура компонентов

Проект использует слоистую архитектуру компонентов, основанную на принципах атомарного дизайна и разделения ответственности.

## Структура директорий

```
src/
├── components/              # Компоненты
│   ├── atoms/              # Атомарные компоненты (атомы)
│   ├── elements/           # Базовые элементы (молекулы)
│   ├── blocks/             # Составные блоки (организмы)
│   ├── compounds/          # Сложные компоненты (шаблоны)
│   └── index.ts            # Главный экспорт всех компонентов
├── hooks/                  # Vue Composables
│   ├── useTheme.ts         # Хук для определения темы
│   └── index.ts            # Экспорт хуков
└── types/                  # TypeScript типы
```

## Принципы архитектуры

### 1. Слоистая структура
- **Atoms** → **Elements** → **Blocks** → **Compounds**
- Каждый слой может использовать компоненты из предыдущих слоев
- Запрещены циклические зависимости между слоями

### 2. Разделение ответственности
- **Atoms**: самые базовые, неделимые UI элементы
- **Elements**: базовые элементы, которые могут содержать atoms
- **Blocks**: составные блоки с бизнес-логикой
- **Compounds**: сложные компоненты, управляющие состоянием

### 3. Принцип композиции
- Сложные компоненты собираются из простых
- Легко комбинировать и перестраивать
- Переиспользование на всех уровнях

### 4. Использование хуков
- **Hooks** предоставляют общую логику для компонентов
- Компоненты используют хуки для получения данных и состояния
- Хуки инкапсулируют сложную логику (API, observers, timers)

## Правила использования

### Atoms (Атомарные компоненты)
✅ **Можно:**
- Использовать самостоятельно
- Содержать только базовую логику
- Использовать Vue composables
- Управляться через props

❌ **Нельзя:**
- Зависеть от других компонентов
- Содержать сложную бизнес-логику
- Импортировать другие компоненты
- Использовать CSS переменные тем

### Elements (Базовые элементы)
✅ **Можно:**
- Использовать atoms
- Содержать простую логику отображения
- Переиспользовать в любом контексте

❌ **Нельзя:**
- Зависеть от blocks или compounds
- Содержать бизнес-логику
- Управлять состоянием других компонентов

### Blocks (Составные блоки)
✅ **Можно:**
- Использовать atoms и elements
- Содержать собственную бизнес-логику
- Переиспользовать в разных compounds
- Использовать хуки для получения данных

❌ **Нельзя:**
- Зависеть от compounds
- Управлять глобальным состоянием
- Содержать логику навигации

### Compounds (Сложные компоненты)
✅ **Можно:**
- Использовать atoms, elements и blocks
- Управлять состоянием и взаимодействиями
- Представлять целые секции интерфейса
- Использовать хуки для сложной логики

❌ **Нельзя:**
- Создавать циклические зависимости
- Дублировать логику из blocks
- Нарушать принцип единственной ответственности

### Hooks (Vue Composables)
✅ **Можно:**
- Инкапсулировать общую логику
- Использовать в любом компоненте
- Управлять жизненным циклом ресурсов
- Предоставлять реактивные значения

❌ **Нельзя:**
- Содержать UI логику
- Зависеть от конкретных компонентов
- Нарушать принцип единственной ответственности

## Преимущества архитектуры

1. **Масштабируемость** - легко добавлять новые компоненты и хуки
2. **Переиспользование** - atoms, elements и хуки используются многократно
3. **Тестируемость** - каждый слой можно тестировать независимо
4. **Поддерживаемость** - четкое разделение ответственности
5. **Гибкость** - легко комбинировать компоненты по-новому
6. **Чистота кода** - хуки инкапсулируют сложную логику

## Примеры использования

```vue
<!-- Compound использует Block -->
<CardWithTheme>
  <!-- Block использует Elements и Hooks -->
  <UserProfileCard>
    <!-- Elements используют Atoms -->
    <CardHeader />
    <CardBody />
    <CardFooter />
  </UserProfileCard>
</CardWithTheme>

<!-- Atoms используются самостоятельно -->
<AvatarIcon icon-type="starwars" />

<!-- Hooks используются в компонентах -->
<script setup>
import { useTheme } from '@/hooks'
const { currentTheme } = useTheme()
</script>
```

## Миграция компонентов

При добавлении новых компонентов:
1. Определите уровень сложности
2. Разместите в соответствующей директории
3. Обновите импорты и экспорты
4. Следуйте принципам архитектуры
5. Используйте хуки для общей логики
